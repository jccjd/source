---
date: 2019-11-08
tags:
- mysql
---

### 什么是mysql

> `mysql`是一种关系型数据库， 是非常常用的数据库，`mysql`是开源的，方便扩展，mysql的默认端口是`3306`

### mysql的两种引擎

> **MYISAM:** 不支持事务，不支持外键，表锁，插入数据时锁定整张表，查询函数时无需扫描整表
>
> **INNODB:** 支持事务，支持外键，行锁，查表总行数时，全表扫描

*与sql标准不同的地方在于InnoDB存储引擎在 `repeatable-read`事务隔离级别下使用的是 `Next-key Lock`锁算法，因此可以避免幻读的产生，InnoDB在分布式事务的情况下会用到`serilaizable`隔离级别*

### 事务

事务是逻辑上的一组操作，要么都执行，要么都不执行

事务的四大特性：

- 原子性: 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用
- 一致性: 执行事务前后，数据保持一致，多个事务对同一数据读取的结果是相同的；
- 隔离性: 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的
- 持久性: 一个事务被提交之后。它对数据库中的改变是持久的，即数据库发生故障也不应该对其有任何影响

**并发事务的问题：**

>**脏读：**当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务以访问了这个数据，然后使用了这个数据，因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是脏数据，
>
>**丢失修改：**在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改这个数据后，第二个事务以修改了这个数据，这样第一个事务内的修改结果就被丢失，因此称为丢失修改
>
>**不可重复读：**在一个事务内多次读取一个数据。在整个事务还没结束时，另一个事务以访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据不一样，
>
>**幻读：**幻读与不可重复读类似。它发生在一个事务读取几行数据，然后另一个事务插入了一些数据，在随后的查询中，第一个事务发现多了一些原本不存在的记录，



### 事务的隔离级别

> **read-uncommitted:** 最低的隔离级别，允许读取尚未提交的数据变更
>
> **read-committed:** 允许读取并发事务已经提交的数据，
>
> **repeatable-read:** 对同一字段的多次读取结果都是一致的，除非数据是被本身事务修改
>
> **serilizable:** 最高级别的隔离，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰。

**隔离级别解决事务问题**

|     隔离级别     | 脏读 | 不可重复读 | 幻读 |
| :--------------: | :--: | :--------: | :--: |
| read-uncommitted |  X   |     X      |  X   |
|  read-committed  |  O   |     X      |  X   |
| repeatable-read  |  O   |     O      |  X   |
|  serilalizable   |  O   |     O      |  O   |

*事务隔离级别为读提交时，写数据只会锁住响应行*

*事务隔离级别为可重复读时，如果检索条件有索引，默认加锁方式是next-key，如果检索条件没有索引，更新数据时会锁住整张表，*

*事务隔离级别为串行化时，读写数据都会锁住整张表*

*隔离级别越高，越能保证数据的完整性和一致性，但对并发性能的影响有越大*





### 索引

使用索引能够提高MySQL的查询效率，

.............
